/**
 * @file sessionmanager.cpp Ralf session manager.
 *
 * Project Clearwater - IMS in the Cloud
 * Copyright (C) 2013  Metaswitch Networks Ltd
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version, along with the "Special Exception" for use of
 * the program along with SSL, set forth below. This program is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details. You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * The author can be reached by email at clearwater@metaswitch.com or by
 * post at Metaswitch Networks Ltd, 100 Church St, Enfield EN2 6BQ, UK
 *
 * Special Exception
 * Metaswitch Networks Ltd  grants you permission to copy, modify,
 * propagate, and distribute a work formed by combining OpenSSL with The
 * Software, or a work derivative of such a combination, even if such
 * copying, modification, propagation, or distribution would otherwise
 * violate the terms of the GPL. You must comply with the GPL in all
 * respects for all of the code used other than OpenSSL.
 * "OpenSSL" means OpenSSL toolkit software distributed by the OpenSSL
 * Project and licensed under the OpenSSL Licenses, or a work based on such
 * software and licensed under the OpenSSL Licenses.
 * "OpenSSL Licenses" means the OpenSSL License and Original SSLeay License
 * under which the OpenSSL Project distributes the OpenSSL toolkit software,
 * as those licenses appear in the file LICENSE-OPENSSL.
 */

#include <string>
#include <map>

#include "message.hpp"
#include "sessionstore.h"
#include "session_manager.hpp"
#include "log.h"
#include "peer_message_sender.hpp"

void SessionManager::handle(Message* msg)
{
  SessionStore::Session* sess = NULL;

  if ((msg->record_type.compare("INTERIM") == 0) ||
      (msg->record_type.compare("STOP") == 0))
  {
    // This relates to an existing session
    sess = _store->get_session_data(msg->call_id);

    if (sess == NULL)
    {
      // No record of the session - ignore the request
      LOG_INFO("Session for %s not found in database, ignoring message", msg->call_id.c_str());
      delete msg;
      return;
    }


    if (msg->record_type.compare("INTERIM") == 0)
    {
      sess->acct_record_number += 1;
      // Update the store with the incremented accounting record number
      bool success = _store->set_session_data(msg->call_id, sess);
      if (!success)
      {
        // Someone has written conflicting data since we read this, so start processing this message again
        return this->handle(msg);
      }
    }
    else if  (msg->record_type.compare("STOP") == 0)
    {
      // Delete the session from the store
      _store->delete_session_data(msg->call_id);
      LOG_INFO("Received STOP for session %s, deleting session", msg->call_id.c_str());
    }

    msg->accounting_record_number = sess->acct_record_number;
    msg->ccfs = sess->ccf;
    msg->session_id = sess->session_id;
    msg->timer_id = sess->timer_id;
    msg->session_refresh_time = sess->session_refresh_time;
    msg->interim_interval = sess->interim_interval;

  }
  else
  {
    /* First message in a session: set accounting record number to 1.
     *
     * Session refresh time and CCFs on the message were filled in by the controller based on the JSON.
     *
     * Timer ID will be generated by Chronos on a POST later.
     * Interim interval and session ID will be determined by the CCF and filled in once we have that Diameter response.
     */
    msg->accounting_record_number = 1;
  };

  // go to the Diameter stack
  PeerMessageSender* pm= new PeerMessageSender(msg, this); // self-deleting
  pm->send();

}

rapidjson::Value::Member* SessionManager::create_opaque_data(Message* msg)
{
  // Some RapidJSON parsing code goes here to determine the "opaque data".
  return msg->received_json->FindMember("event");
}

void SessionManager::on_ccf_response (bool accepted, int interim_interval, std::string session_id, int rc, Message* msg)
{
  if (accepted)
  {
    if ((msg->record_type.compare("INTERIM") == 0) && !msg->timer_interim)

    {
      // Interim message generated by Sprout, so update a timer to generate recurring INTERIMs

      /* Doesn't really work
      _timer_conn->send_put(msg->timer_id,
          interim_interval,
          msg->session_refresh_time,
          msg->call_id,
          create_opaque_data()); */
    }
    else if (msg->record_type.compare("START") == 0)
    {
      // New message from Sprout - create a new timer then insert the session into the store

      /* Doesn't really work

      _timer_conn->send_post(msg->timer_id,
          interim_interval,
          msg->session_refresh_time,
          msg->call_id,
          create_opaque_data()); */

      std::string timer_id;

      LOG_INFO("Writing session to store");
      SessionStore::Session* sess = new SessionStore::Session(); // Always safe - at this point sess is only non-NULL for INTERIM/STOP.
      sess->session_id = session_id;
      sess->interim_interval = interim_interval;

      sess->timer_id = timer_id;

      sess->ccf = msg->ccfs;
      sess->acct_record_number = msg->accounting_record_number;
      sess->session_refresh_time = msg->session_refresh_time;

      // Do this unconditionally - if it fails, this processing has already been done elsewhere
      _store->set_session_data(msg->call_id, sess);
      delete sess;
    }

  } else {
    LOG_WARNING("Session for %s received error from CDF", msg->call_id.c_str());
    if ((msg->record_type.compare("INTERIM") == 0))
    {
      if (rc == 5002)
      {
        // 5002 means the CDF has no record of this session. It's pointless to send any
        // more messages - delete the session from the store.
        LOG_INFO("Session for %s received 5002 error from CDF, deleting", msg->call_id.c_str());
        _store->delete_session_data(msg->call_id);
      }
      else if (!msg->timer_interim)
      {
        // Interim failed, but the CDF probably still knows about the session,
        // so keep sending them. We don't do this for START - if a START fails we don't record the session.

        // In error conditions our CCF might not have returned an interim interval,
        // so use the one from the store.
        if (interim_interval == 0)
        {
          interim_interval = msg->interim_interval;
        }

        /* Doesn't really work
        _timer_conn->send_put(msg->timer_id,
          msg->interim_interval,
          msg->session_refresh_time,
          msg->call_id,
          create_opaque_data()); */
      }
    }

  }

  // Everything is finished and we're the last holder of the Message object - delete it.
  delete msg;
}
