/**
 * @file sessionmanager.cpp Ralf session manager.
 *
 * Project Clearwater - IMS in the Cloud
 * Copyright (C) 2013  Metaswitch Networks Ltd
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version, along with the "Special Exception" for use of
 * the program along with SSL, set forth below. This program is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details. You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * The author can be reached by email at clearwater@metaswitch.com or by
 * post at Metaswitch Networks Ltd, 100 Church St, Enfield EN2 6BQ, UK
 *
 * Special Exception
 * Metaswitch Networks Ltd  grants you permission to copy, modify,
 * propagate, and distribute a work formed by combining OpenSSL with The
 * Software, or a work derivative of such a combination, even if such
 * copying, modification, propagation, or distribution would otherwise
 * violate the terms of the GPL. You must comply with the GPL in all
 * respects for all of the code used other than OpenSSL.
 * "OpenSSL" means OpenSSL toolkit software distributed by the OpenSSL
 * Project and licensed under the OpenSSL Licenses, or a work based on such
 * software and licensed under the OpenSSL Licenses.
 * "OpenSSL Licenses" means the OpenSSL License and Original SSLeay License
 * under which the OpenSSL Project distributes the OpenSSL toolkit software,
 * as those licenses appear in the file LICENSE-OPENSSL.
 */

#include <string>
#include <map>

#include "message.hpp"
#include "sessionstore.h"
#include "session_manager.hpp"
#include "log.h"

void SessionManager::handle(Message* msg)
{
  std::map<std::string, std::string> ccfs;
  SessionStore::Session* sess = NULL;
  std::string timer_id;

  if ((msg->record_type.compare("INTERIM") == 0) ||
      (msg->record_type.compare("STOP") == 0))
  {
    // This relates to an existing session
    sess = _store->get_session_data(msg->call_id);

    if (sess == NULL)
    {
      // No record of the session - ignore the request
      LOG_INFO("Session for %s not found in database, ignoring message", msg->call_id.c_str());
      delete msg;
      return;
    }


    if (msg->record_type.compare("INTERIM") == 0)
    {
      sess->acct_record_number += 1;
      // Update the store with the incremented accounting record number
      bool success = _store->set_session_data(msg->call_id, sess);
      if (!success)
      {
        // Someone has written conflicting data since we read this, so start processing this message again
        return this->handle(msg);
      }
    }
    else if  (msg->record_type.compare("STOP") == 0)
    {
      // Delete the session from the store
      _store->delete_session_data(msg->call_id, sess);
      LOG_INFO("Received STOP for session %s, deleting session", msg->call_id.c_str());
    }

    msg->accounting_record_number = sess->acct_record_number;
    msg->ccfs = sess->ccf;
    msg->session_id = sess->session_id;
    timer_id = sess->timer_id;

  }
  else
  {
    // First message in a session - set accounting record number to 1 and randomly generate a timer ID
    msg->accounting_record_number = 1;
  };

  int rc;
  int interim_interval;
  bool accepted = true;
  // go to the Diameter stack
  //accepted = _pm->send(msg, &interim_interval, &msg->session_id, &rc);

  if (accepted) {
    if ((msg->record_type.compare("START") == 0) ||
        ((msg->record_type.compare("INTERIM") == 0) && !msg->timer_interim))
    {
      // Message generated by Sprout, so set a timer to generate recurring INTERIMs

      /* Some RapidJSON parsing code goes here */

      /* Doesn't really work
      _timer_conn->send_put(timer_id,
          interim_interval,
          msg->call_id,
          opaque); */
    }

    if (msg->record_type.compare("START") == 0)
    {
      LOG_INFO("Writing session to store");
      sess = new SessionStore::Session(); // Always safe - at this point sess is only non-NULL for INTERIM/STOP.
      sess->session_id = msg->session_id;
      sess->ccf = msg->ccfs;
      sess->acct_record_number = msg->accounting_record_number;
      sess->timer_id = timer_id;
      sess->session_refresh_time = interim_interval;

      // Do this unconditionally - if it fails, this processing has already been done elsewhere
      _store->set_session_data(msg->call_id, sess);
    }

  } else {
    LOG_WARNING("Session for %s received error from CDF", msg->call_id.c_str());
    if ((msg->record_type.compare("INTERIM") == 0)
        && (rc = 5002))
    {
      // 5002 means the CDF has no record of this session. It's pointless to send any more messages - delete the session from the store.
      LOG_INFO("Session for %s received 5002 error from CDF, deleting", msg->call_id.c_str());
      _store->delete_session_data(msg->call_id, sess);
    }
    else if (!msg->timer_interim)
    {
      // Interim failed, but the CDF probably still knows about the session,
      // so keep sending them. We don't do this for START - if a START fails we don't record the session.

      /* Doesn't really work
      _timer_conn->send_put(timer_id,
          interim_interval,
          msg->call_id,
          opaque); */
    }

  }

  delete sess; // Always safe - if we haven't created a session it's NULL.
  delete msg;
}
